# tasks run in order.
# match is to $state->{scratch}{text} unless match=>'line' is set
# set $state->{scratch}{break} = 1; to end processing
# states?
# output (timestamp, host, resource_type, resource, action, value) 
[
{
    regex => 'n/a',
    init => [
        sub { my ($state) = @_;
            $state->{current_matcher}{disabled} = 1; 
            $state->{last_ts} = '2017-01-01 00:00:00'; 
            $state->{headers} = 'timestamp,node,resource_type,resource,action,value'; 
        } 
    ]
},
# first the non-datetime lines
{
    regex => '^Segmentation fault in thread',
    match => 'line',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{last_ts});
            $state->{stats}{$ts}{$node}{process}{segfault}{count}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^(Thread \d+|#\d+)',
    match => 'line',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{last_ts});
            $state->{stats}{$ts}{$node}{process}{stackdump}{count}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
# everything after here should have a datetime and level
{
    regex => '^(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d+) (\S+):\s(.*)',
    match => 'line',
    unmatched => [
        sub { my ($state) = @_;
            print STDERR "Bad line: $state->{input}{line}.\n";
            $state->{scratch}{break} = 1; 
        }
    ],
    matched => [
        sub { my ($state) = @_;
            @{$state->{scratch}}{'timestamp','level','text'} = @{$state->{scratch}{values}};
            ( $state->{scratch}{timestamp_s} = $state->{scratch}{timestamp} ) =~ s/\.\d*$//;
            ( $state->{scratch}{timestamp_m} = $state->{scratch}{timestamp_s} ) =~ s/:\d\d$/:00/;
            # store this for non-ts lines (stack dumps)
            $state->{last_ts} = $state->{scratch}{timestamp_s};
        } 
    ],
},
{
    regex => '*',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts, $level) = ($state->{input}{node}, $state->{scratch}{timestamp_m}, $state->{scratch}{level});
            $state->{stats}{$ts}{$node}{logging}{lines}{count}++;
            $state->{stats}{$ts}{$node}{log_level}{$level}{count}++;
        } 
    ]
},
# TODO is this any use?
{
    regex => '*',
    extracts => [ qr{/Forests/([a-zA-Z0-9_-]+)}, qr{of forest ([^:]+):} ],
    matched => [ 
        sub { my ($state) = @_;
            my ($node, $ts, $text) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{text});
            # ok to just put all possibilities together?
            my @forests = ();
            # current_matcher is me
            foreach my $regex (@{$state->{current_matcher}{extracts}}) {
                push @forests, ($text =~ /$regex/g);
            }
            @{$state->{scratch}{forests}} = @forests;
        } 
    ]
},
{
    regex => '^(Merged|Saved|Deleted) (\d+) MB in (\d+) sec .*? at (\d+) MB',
    matched => [
        sub { my ($state) = @_;
            my ($op, $sec, $MB, $rate) = @{$state->{scratch}{values}};
            unless (defined $rate) { return }
            $op = lc ($op);
            my ($node, $ts, $forest) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{forests}[0]);
            $state->{stats}{$ts}{$node}{forest}{$forest}{count}++;
            push @{$state->{stats}{$ts}{$node}{forest}{$forest}{"${op}_rate"}}, $rate;
            push @{$state->{stats}{$ts}{$node}{forest}{$forest}{"${op}_mb"}}, $MB;
            push @{$state->{stats}{$ts}{$node}{forest}{$forest}{"${op}_duration"}}, $sec;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    # 2016-10-06 08:46:55.296 Info: Forest Triggers-1 state changed from start closing to middle closing because shutting down
    regex => '^Forest (\S+) state changed .* to (.*)',
    matched => [
        sub { my ($state) = @_;
            my ($forest, $text) = @{$state->{scratch}{values}};
            my $new_state = $text;
            $new_state =~ s/ because.*//;
            $new_state =~ s/ /_/;
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            $state->{stats}{$ts}{$node}{forest_state}{$forest}{$state} = 1;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^(Hung|Canary thread sleep was) (\d+) ',
    matched => [
        sub { my ($state) = @_;
            my ($op, $s) = @{$state->{scratch}{values}};
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            my $action = $op eq 'Hung' ? 'hung' : 'canary';
            push @{$state->{stats}{$ts}{$node}{process}{$action}{duration}}, $s;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^Forest (\S+) fast query timestamp .* by (\d+) ms',
    matched => [
        sub { my ($state) = @_;
            my ($forest, $ms) = @{$state->{scratch}{values}};
            $forest = 'Forest-' . $forest;
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            push @{$state->{stats}{$ts}{$node}{$forest}{ts_lag}{duration}}, $ms;
            $state->{stats}{$ts}{$node}{$forest}{ts_lag}{count}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^Starting MarkLogic Server',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            $state->{stats}{$ts}{$node}{process}{restart}{count}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^\[Event:id=(.*?)\]',
    matched => [
        sub { my ($state) = @_;
            my $event_name = 'Event_' . $state->{scratch}{values}[0];
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            $event_name =~ s/ /-/g;
            #print "event match: $event_name.\n";
            $state->{stats}{$ts}{$node}{trace_events}{$event_name}{count}++;
        } 
    ]
},
{
    # TODO maybe verify as in logalyzer?
    regex => '((?:[A-Z]+|X509)-(?:[A-Z]+)): ',
    matched => [
        sub { my ($state) = @_;
            my @codes = @{$state->{scratch}{values}};
            my ($node, $ts, $text) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{text});
            foreach my $code (@codes) {
                $state->{stats}{$ts}{$node}{code}{$code}{count}++;
                foreach my $forest (@{$state->{scratch}{forests}}) { $state->{stats}{$ts}{$node}{forest}{$forest}{$code}++ }
                if ($code eq 'XDMP-EXTIME') {
                    my ($app_server) = ($text =~ /^(\S+):\s+XDMP-EXTIME:/);
                    # if ($app_server) { $state->{stats}{$ts}{$node}{"Server-$app_server"}{$code}++ }
                }
            }
        }
    ]
}
]
