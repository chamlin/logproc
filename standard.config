# output (timestamp, host, resource, action, value) 
# states?
[
{
    regex => 'n/a',
    init => [
        sub { my ($state) = @_;
            $state->{value_aggregates} = {
                # TODO  labels wrt granularity?
                merged_rate => { op => 'avg' },
                merged_mb => { op => 'sum' },
                saved_rate => { op => 'avg' },
                ts_lag_ms => { op => 'avg' },
                saved_mb => { op => 'sum' },
                hung => { op => 'sum' },
                canary => { op => 'sum' },
                default => { op => 'avg' },
            };
            $state->{current_matcher}{disabled} = 1; 
            $state->{last_ts} = '2017-01-01 00:00:00'; 
        } 
    ]
},
# first the non-datetime lines
{
    regex => '^Segmentation fault in thread',
    match => 'line',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{last_ts});
            $state->{stats}{$ts}{$node}{process}{segfault}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^(Thread \d+|#\d+)',
    match => 'line',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{last_ts});
            $state->{stats}{$ts}{$node}{process}{stackdump}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
# everything after here should have a datetime and level
{
    regex => '^(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d+) (\S+):\s(.*)',
    match => 'line',
    unmatched => [
        sub { my ($state) = @_;
            print STDERR "Bad line: $state->{input}{line}.\n";
            $state->{scratch}{break} = 1; 
        }
    ],
    matched => [
        sub { my ($state) = @_;
            @{$state->{scratch}}{'timestamp','level','text'} = @{$state->{scratch}{values}};
            ( $state->{scratch}{timestamp_s} = $state->{scratch}{timestamp} ) =~ s/\.\d*$//;
            ( $state->{scratch}{timestamp_m} = $state->{scratch}{timestamp_s} ) =~ s/:\d\d$/:00/;
            $state->{last_ts} = $state->{scratch}{timestamp_s};
        } 
    ],
},
{
    regex => '*',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts, $level) = ($state->{input}{node}, $state->{scratch}{timestamp_m}, $state->{scratch}{level});
            $state->{stats}{$ts}{$node}{error_log}{lines}++;
            $state->{stats}{$ts}{$node}{message_level}{$level}++;
        } 
    ]
},
{
    regex => '*',
    extracts => [ qr{/Forests/([a-zA-Z0-9_-]+)}, qr{of forest ([^:]+):} ],
    matched => [ 
        sub { my ($state) = @_;
            my ($node, $ts, $text) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{text});
            # ok to just put all possibilities together?
            my @forests = ();
            # current_matcher is me
            foreach my $regex (@{$state->{current_matcher}{extracts}}) {
                push @forests, ($text =~ /$regex/g);
            }
            @{$state->{scratch}{forests}} = @forests;
        } 
    ]
},
{
    regex => '^(Merged|Saved) (\d+) MB in (\d+) sec at (\d+) MB',
    matched => [
        sub { my ($state) = @_;
            my ($op, $MB, $s, $rate) = @{$state->{scratch}{values}};
            unless (defined $rate) { return }
            $op = lc ($op);
            my ($node, $ts, $forest) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{forests}[0]);
            my $resource = "Forest-$forest";
            $state->{stats}{$ts}{$node}{$resource}{$op}++;
            push @{$state->{stats}{$ts}{$node}{$resource}{"${op}_rate"}}, $rate;
            push @{$state->{stats}{$ts}{$node}{$resource}{"${op}_mb"}}, $MB;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    # 2016-10-06 08:46:55.296 Info: Forest Triggers-1 state changed from start closing to middle closing because shutting down
    regex => '^Forest (\S+) state changed',
    matched => [
        sub { my ($state) = @_;
            my $forest = 'Forest-' . $state->{scratch}{values}[0];
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            $state->{stats}{$ts}{$node}{$forest}{state_change}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^(Hung|Canary thread sleep was) (\d+) ',
    matched => [
        sub { my ($state) = @_;
            my ($op, $s) = @{$state->{scratch}{values}};
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            my $action = $op eq 'Hung' ? 'hung' : 'canary';
            push @{$state->{stats}{$ts}{$node}{_}{canary}}, $s;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^Forest (\S+) fast query timestamp .* by (\d+) ms',
    matched => [
        sub { my ($state) = @_;
            my ($forest, $ms) = @{$state->{scratch}{values}};
            $forest = 'Forest-' . $forest;
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            push @{$state->{stats}{$ts}{$node}{$forest}{ts_lag_ms}}, $ms;
            $state->{stats}{$ts}{$node}{$forest}{ts_lag}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^\[Event:id=(.*?)\]',
    matched => [
        sub { my ($state) = @_;
            my $event_name = 'Event_' . $state->{scratch}{values}[0];
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            $event_name =~ s/ /-/g;
            #print "event match: $event_name.\n";
            $state->{stats}{$ts}{$node}{trace_events}{$event_name}++;
        } 
    ]
},
{
    # TODO maybe verify as in logalyzer?
    regex => '((?:[A-Z]+|X509)-(?:[A-Z]+)): ',
    matched => [
        sub { my ($state) = @_;
            my @codes = @{$state->{scratch}{values}};
            my ($node, $ts, $text) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{text});
            foreach my $code (@codes) {
                $state->{stats}{$ts}{$node}{code}{$code}++;
                foreach my $forest (@{$state->{scratch}{forests}}) { $state->{stats}{$ts}{$node}{"Forest-$forest"}{$code}++ }
                if ($code eq 'XDMP-EXTIME') {
                    my ($app_server) = ($text =~ /^(\S+):\s+XDMP-EXTIME:/);
                    # if ($app_server) { $state->{stats}{$ts}{$node}{"Server-$app_server"}{$code}++ }
                }
            }
        }
    ]
}
]
