# tasks run in order.
# match is to $state->{scratch}{text} unless match=>'line' is set
# set $state->{scratch}{break} = 1; to end processing
# states?
# output (timestamp, host, reading, resource, action, value) 
[
{
    regex => 'n/a',
    init => [
        sub { my ($state) = @_;
            $state->{current_matcher}{disabled} = 1; 
            $state->{last_ts} = '2017-01-01 00:00:00'; 
            $state->{headers} = 'timestamp,node,reading,resource,action,value'; 
        } 
    ]
},
# first the non-datetime lines
{
    regex => '^Segmentation fault in thread',
    match => 'line',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{last_ts});
            push @{$state->{ship}}, [$ts,$node,'event','process','segfault','1'];
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^(Thread \d+|#\d+)',
    match => 'line',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{last_ts});
            $state->{counts}{$ts}{$node}{lines}{process}{stackdump}++;
            $state->{scratch}{break} = 1; 
        } 
    ]
},
# everything after here should have a datetime and level
{
    regex => '^(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d+) (\S+):\s(.*)',
    match => 'line',
    unmatched => [
        sub { my ($state) = @_;
            print STDERR "Bad line: $state->{input}{line}.\n";
            $state->{scratch}{break} = 1; 
        }
    ],
    matched => [
        sub { my ($state) = @_;
            @{$state->{scratch}}{'timestamp','level','text'} = @{$state->{scratch}{values}};
            ( $state->{scratch}{timestamp_s} = $state->{scratch}{timestamp} ) =~ s/\.\d*$//;
            ( $state->{scratch}{timestamp_m} = $state->{scratch}{timestamp_s} ) =~ s/:\d\d$/:00/;
            # store this for non-ts lines (stack dumps)
            $state->{last_ts} = $state->{scratch}{timestamp_s};
        } 
    ],
},
{
    regex => '*',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts, $level) = ($state->{input}{node}, $state->{scratch}{timestamp_m}, $state->{scratch}{level});
            $state->{counts}{$ts}{$node}{count}{log_level}{$level}++;
        } 
    ]
},
# TODO is this any use?
{
    regex => '*',
    extracts => [ qr{/Forests/([a-zA-Z0-9_-]+)}, qr{of forest ([^:]+):} ],
    matched => [ 
        sub { my ($state) = @_;
            my ($node, $ts, $text) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{text});
            # ok to just put all possibilities together?
            my @forests = ();
            # current_matcher is me
            foreach my $regex (@{$state->{current_matcher}{extracts}}) {
                push @forests, ($text =~ /$regex/g);
            }
            @{$state->{scratch}{forests}} = @forests;
        } 
    ]
},
{
    regex => '^(Merged|Saved|Deleted) (\d+) MB in (\d+) sec at (\d+) MB',
    matched => [
        sub { my ($state) = @_;
            my ($op, $MB, $sec, $rate) = @{$state->{scratch}{values}};
            unless (defined $rate) { return }
            $op = lc ($op);
            # deletes can be from backups
            # Deleted 1 MB in 1 sec at 62 MB/sec /backups/daily_full/Fab/20170520-0030005373580
            unless (@{$state->{scratch}{forests}}) { return }
            my ($node, $ts, $forest) = ($state->{input}{node}, $state->{scratch}{timestamp_s}, $state->{scratch}{forests}[0]);
            push @{$state->{ship}}, [$ts,$node,'rate',$forest,$op,$rate];
            push @{$state->{ship}}, [$ts,$node,'size',$forest,$op,$MB];
            push @{$state->{ship}}, [$ts,$node,'duration',$forest,$op,$sec];
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    # 2016-10-06 08:46:55.296 Info: Forest Triggers-1 state changed from start closing to middle closing because shutting down
    regex => '^Forest (\S+) state changed .* to (.*)',
    matched => [
        sub { my ($state) = @_;
            my ($forest, $text) = @{$state->{scratch}{values}};
            my $new_state = $text;
            $new_state =~ s/ because.*$//;
            $new_state =~ s/ /_/;
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            push @{$state->{ship}}, [$ts,$node,'forest_state',$forest,$new_state,1];
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^(Hung|Canary thread sleep was) (\d+) ',
    matched => [
        sub { my ($state) = @_;
            my ($op, $s) = @{$state->{scratch}{values}};
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            my $action = $op eq 'Hung' ? 'hung' : 'canary';
            push @{$state->{ship}}, [$ts,$node,'duration','process',$action,$s];
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^Forest (\S+) fast query timestamp .* by (\d+) ms',
    matched => [
        sub { my ($state) = @_;
            my ($forest, $ms) = @{$state->{scratch}{values}};
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            push @{$state->{ship}}, [$ts,$node,'duration',$forest,'ts_lag',$ms];
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    regex => '^Starting MarkLogic Server',
    matched => [
        sub { my ($state) = @_;
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            push @{$state->{ship}}, [$ts,$node,'event','process','restart','1'];
            $state->{scratch}{break} = 1; 
        } 
    ]
},
{
    # todo - handle some interesting ones.
    regex => '^\[Event:id=(.*?)\]',
    matched => [
        sub { my ($state) = @_;
            my $event_name = 'Event_' . $state->{scratch}{values}[0];
            my ($node, $ts) = ($state->{input}{node}, $state->{scratch}{timestamp_s});
            $event_name =~ s/ /-/g;
            #print "event match: $event_name.\n";
            $state->{counts}{$ts}{$node}{count}{trace_event}{$event_name}++;
            # guess more specific stuff here?
        } 
    ]
},
{
    # TODO maybe verify as in logalyzer?
    regex => '((?:[A-Z]+|X509)-(?:[A-Z]+)): ',
    matched => [
        sub { my ($state) = @_;
            my @codes = @{$state->{scratch}{values}};
            my ($node, $ts, $text) = ($state->{input}{node}, $state->{scratch}{timestamp_m}, $state->{scratch}{text});
            foreach my $code (@codes) {
                $state->{counts}{$ts}{$node}{count}{code}{$code}++;
                foreach my $forest (@{$state->{scratch}{forests}}) {
                    $state->{counts}{$ts}{$node}{forest_codes}{$forest}{$code}++
                }
                # any particular stuff, do it here.
                if ($code eq 'XDMP-EXTIME') {
                    my ($app_server) = ($text =~ /^(\S+):\s+XDMP-EXTIME:/);
                    # if ($app_server) { $state->{stats}{$ts}{$node}{"Server-$app_server"}{$code}++ }
                }
            }
        }
    ]
}
]
